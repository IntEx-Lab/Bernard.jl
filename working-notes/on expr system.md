待发送给AI：

我觉得我们应该再看一下我们的Desmos表达式管理系统，感觉设计的有点不太对。

我们的目的是让用户可以程序化构建Desmos图表对象，但同时也要保证构建过程符合Desmos对其图表的约束限制。

Desmos里有一个简单的变量系统。Desmos的”表达式列表“里有若干行数学公式，可编辑。这些公式在效果上并列，不分先后，但它们的顺序会影响各个图象的层叠顺序。
一行公式可以为以下几种类型：
- 表达式，如`2 + a`（a为已定义变量），可以求值；
- 变量定义，如`a = 3`，本质也是表达式，也可求值，但它定义了一个变量，占用了一个名称；x, y名称不可定义。
- 函数定义，如`f(x) = x^2`，同样占用一个名称；
- 临时函数，用于快捷绘制特定函数图象而不必定义它，如`x^2`，`sin(x)`，`2*f(x)`（f(x)已定义）等，以及`y = 2*x^2`，`V = (4/3)*pi*r^3`（V，r未定义）等。
  总结一下，形如`b = f(a)`，`f(x)`的表达式，其中b, a为任意的相异未定义符号，可以为x和y，`y = f(a)`会绘制y轴为因变量的图象，`x = f(a)`会绘制x轴为因变量的图象。`f(x)`形式必须是关于"x"唯一一个未定义变量的表达式。
- 方程/不等式，如`x^2 + y^2 = 4`，是关于x和y的方程或不等式，Desmos会绘制其图象。
- 回归，如`Y ~ kX + b`，其中Y和X是长度相等的数值列表，代表待回归的数据。k和b未在环境中定义，则被认定为待回归系数，Desmos会计算回归结果，即k和b的值，同时计算一个残差（残差变量名由Desmos自动指定，如`e_1`，但在对Desmos state进行直接操作时我们可以手动指定残差变量名为任意名称。）。一个回归表达式对Desmos系统的影响在于引入了新的变量定义（各个待回归变量和一个残差变量的定义）。

补充说明：
- 所有公式类型都可以使用/引用/调用 已有的变量定义和函数定义。
- 表达式有若干个子类型，个别子类型可以绘图（如点、点列表）；方程、不等式、函数定义、回归等等也可以绘图。可绘图的公式拥有若干绘图属性（颜色，线宽，透明度等等），而这些属性可以自定义为新的表达式。
  Desmos表达式的子类型可以动态变化，ExprBuild也不对子类型进行约束；Desmos采取的做法是，对任何一行公式都保留/存储绘图属性，而公式的修改或解析变动可以决定各个绘图属性是否有效/无效。ExprBuild也采用同样的做法，任何公式都可以设置绘图属性。
- Desmos里的变量定义，如果是数值类型，那么Desmos会给这行公式下方附加一个滑动条，滑动条可以设置最小值，最大值，步长，而这三个属性同样可以自定义为表达式。

现在看看怎么在ExprBuild里操作这些公式。
我设计的"expl"概念是特指变量定义。它类似表达式，或者说它就是表达式的一种，但是它比普通的表达式多一个变量名的信息。变量名的信息需要存储在公式对象里，甚至如果Julia支持的话存储在对象类型里，不能依靠Julia变量名本身。同时可以设计一个快捷语法来使Desmos变量名等于创建时的Julia变量名。
在ExprBuild里可以通过插值方式把表达式代入其他公式里，所以这可能会引发一个问题：往一个公式里插入两个同时声称自己是“a变量定义”，但值/内容却不同的表达式对象，会引发歧义。
所以这就是依赖检查的目的：
- 对于变量/函数定义，检查它的名称是否与其他定义冲突；
- 对于任意被插值的公式，或者说对于整个公式列表，检查它的依赖系统里每个名称上是否只有唯一的变量定义/函数定义对象。

应用一下我的这些补充内容（应用时还是以你的结构为主）：
- ExprBuild + Julia 对公式系统有一套建模。这其实意味着，虽然Julia语言本身对Julia表达式也有一套建模（Julia程序内部可操作Julia AST），但是我们不采用Julia原生AST建模，而是采用自己设计的对象系统建模这些Desmos公式。明确一下多套建模的概念。
- 