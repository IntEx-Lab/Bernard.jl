# Bernard 项目介绍

> 本项目原名 ExprBuild-Julia/ExprBuild，现更名为 Bernard.jl。

ExprBuild 是一个独立开发和AI协作开发的项目。开发者正在尝试不同的技术路线，本项目工程是基于 Julia 语言的，开发者希望能在这个工程里面学习和验证关键概念，判断 Julia 是否可以成为可选的技术路线，如果可能的话再将工程演进到更成熟的产品形态。

由于开发者需要和AI协作开发，故需要 working-notes 文件夹用于放置"笔记"式的信息文件，供开发者和 AI 同时使用，为每一个新的 AI 示例提供背景信息，以便 AI 理解和工作。请合理使用 working-notes 文件夹，以便开发者和 AI 可以随时查阅和更新信息。

补充信息：
- 开发者有其他语言的编程技术基础，但没有太多的 Julia 编程经验。
- 如果开发者修改了项目介绍，介绍文本可能会跟实际代码工程脱节。默认以文档为准。
- README文档暂缓上线，已重命名为 wip-README.md，待开发者检查。

以下介绍分为两部分：第一部分介绍 ExprBuild 的核心目标与愿景，第二部分则是对各个技术路线的探索。这里是关于 Julia 技术路线的探索。

## 第一部分：核心目标与愿景

### 项目概述

ExprBuild 是一个为 Desmos 图形计算器爱好者设计的开发框架，旨在通过编程方式构建和管理复杂的 Desmos 图表。作为 Desmos 社区粉丝项目，ExprBuild 致力于简化复杂图表的创建过程，使得制作新奇、互动性强的 Desmos 作品变得更加便捷高效。

### 核心目标

1. **降低复杂度**：通过编程方式管理大量表达式，克服 Desmos 原生界面在处理复杂图表时的局限性

2. **自然的数学表达**：提供尽可能接近数学习惯的语法，让创作者能直观地编写表达式，不必过多考虑语法调整

3. **依赖关系管理**：自动追踪和处理表达式之间的依赖关系，确保图表内部公式系统的一致性。
	
	这个目标背后更加广义的目标为：确保用户在程序化构建 Desmos 图表时，符合 Desmos 对一个图表对象要求的所有约束规则。目前这些约束规则主要是"公式之间要有自洽的依赖关系"。

4. **实时反馈循环**：提供高效的开发体验，表达式修改后能立即在预览中查看效果

5. **可程序化操作**：将表达式作为可操作对象，利用编程语言的优势进行批量生成、转换和组织

### 愿景

ExprBuild 希望成为 Desmos 社区创作者的得力助手，通过消除技术障碍，释放创作者的想象力。无论是制作数学游戏、动画展示、复杂可视化，还是艺术作品，ExprBuild 都能提供必要的工具支持，使 Desmos 创作不再受限于原生界面的约束。

### 社区定位

ExprBuild 首先是一个 Desmos 社区粉丝项目，专注于服务社区创作者的需求。我们关注的是如何帮助爱好者制作出更加新奇、复杂的 Desmos 图表，如小游戏、艺术作品或复杂数学演示，而非追求正式的数学或科学研究工具的定位。

### 补充信息 - Desmos 计算原理概述

Desmos 并未开源，我们无法从源代码中直接理解 Desmos 的计算原理，开发者只能站在社区爱好者的角度通过观察现象的方式对 Desmos 的计算原理进行推测。以下是开发者对 Desmos 计算原理的一套理解和建模。

不过虽然 Desmos 并未开源，但是它作为 web 项目对 JS 源代码未做压缩和加密处理，仅作了符号混淆。未来开发者可以考虑开发反混淆表，并从源代码层面理解 Desmos 的更多内部机制。

#### 术语说明

在 ExprBuild 中，我们对 Desmos 相关术语做出以下区分：

- **公式（Formula）**：指 Desmos 中的一行可编辑内容，包括变量定义、函数定义、方程等各种类型。Desmos 官方称之为"表达式"（Expression），但我们采用"公式"这一更广义的术语。

- **表达式（Expression）**：指可求值的数学表达式，是公式的一个子类型。

- **Expr**：在文档和代码里尽量用这个缩写来指代Julia语言的表达式概念，方便讨论和使用Julia语言的宏和元编程能力。

Desmos 的 JSON 状态对象(Desmos state object) 中包含一个"表达式列表"，实际上是各种类型公式的集合，而非仅限于狭义的可求值表达式。

#### Desmos 公式系统

1. **公式并列结构**：所有公式在逻辑上并列存在，不分先后顺序，但它们在列表中的位置会影响它们分别绘制出来图象的视觉层叠顺序。

2. **公式类型**：公式分为以下几种类型：
    - **表达式**：如 `2 + a`（其中 a 为已定义变量），可以求值
    - **变量定义**：如 `a = 3`，定义一个变量并占用该符号（x, y 为保留符号，不可定义）
    - **函数定义**：如 `f(x) = x^2`，定义一个函数并占用函数名
    - **临时函数**：如 `x^2`、`sin(x)`、`y = g(x)`(g(x)已定义)、`V = (4/3)*pi*r^3`(V, r 未定义) 等，用于快速绘制函数图像而无需显式定义。
        - *临时函数解析规则**：
            - 形如 `b = f(a)`，`y = f(a)` 和 `y = f(x)` 的表达式会绘制 y 轴为因变量的图像，a, b 为未定义的符号
            - 形如 `x = f(a)` 和 `x = f(y)` 的表达式会绘制 x 轴为因变量的图像，a 为未定义的符号
            - 形如 `f(x)` 的表达式会绘制 x 轴为自变量 / y 轴为因变量的图像，表达式不得包含 x 以外的未定义符号
    - **方程/不等式**：如 `x^2 + y^2 = 4`，关于x, y的方程不等式，Desmos 会自动绘制其图像
    - **回归**：如 `Y ~ kX + b`，用于数据拟合，会自动计算参数值并引入新的变量定义

	注：
	- x, y为保留符号，不可定义；它们的用途是：
		- 用于绘制临时函数图象，可以使用x,y名称的这一特性大大方便了用户编写临时函数。
		- 用于绘制方程/不等式图象。方程/不等式必须为关于x, y的方程/不等式。
		
		在3D计算器中，保留名称的范围拓展到x, y, z。方程为关于x, y, z的方程，将绘制为曲面。

3. **符号与 Desmos 解析流程**：

   - Desmos 公式系统的符号必须为单个字符或单个字符（这里称为主字符）加下标的形式，下标可为多字符，即`a_{subscript}`形式；多个字符无法整体解析为符号。这里将"符号"定义为公式语义结构的基本单元，排除掉数字、运算符 / 非 `f(·)` 形式的函数。符号包括 `f(·)` 形式的函数，以及成功定义和定义出错的变量，等等。

      - 更准确地说：主字符的范围包括大小写字母和希腊字母，下标所用字符的范围包括大小写字母和数字。
         > 你可能会担心 `a_{subscript}` 下标形式的符号解析方案会遇到包含语法混乱字符串而无法解析的情况；但其实我刚才所提到的 `a_{subscript}` 代码形式并不一定真实，这更多是我刚才用来解释概念的代码形式。\
         > Desmos 使用 Mathquill 库提供有公式的渲染和编辑功能的 UI，所见即所得，所以在用户关于 Desmos 下标的观念里没有下划线和花括号代码，因为他们看不到；在用户的观念里只有真实下标。\
         > 不必担心用户会遇到下划线/花括号代码相关的语法混乱而无法解析符号的情况。对 Desmos 来说，Desmos 在接收来自 Mathquill 模块的公式时确实是以 LaTeX 代码记录公式的，但是 Mathquill 也能保证所传 LaTeX 代码的下标语法是正确的。

      - 有一些特例：

         - 几乎所有的 Desmos 的内置函数都为多字符形式，它们也能被 Desmos 识别为符号（Desmos 会优先将这些多字符的内置函数识别出来），如 `sin(x)` 和 `cos(x)` 可以被 Desmos 识别为符号乃至对应函数。

         - 部分 Desmos 的内置函数也存在/支持一些非 `f(·)` 语法形式，如:
            - 前面提到的三角函数可以省略括号，如 `sin x` 和 `cos x`。
            - 部分内置函数在 `f(·)` 语法形式之外也支持 `arg1.f(args...)` 或 `arg1.f` 语法形式，如 `L_ist1.sort(L_ist2)` 和 `L_ist1.sort`，`a.join(b,c,...)`，`z.real`。

   - 符号可以为已定义（或者说"用户定义 / user-defined"）的的变量、函数，Desmos 内置函数，也可以为未定义的符号，定义出错（语法没有解析出错）的符号，以及有特殊作用的符号（如 `x` 和 `y` 与临时函数功能和方程/不等式功能相关，3D计算器内也包括 `z`；`t` 与参数方程功能相关）。

   - Desmos 本身并没有正式的符号计算功能，但是在 Desmos 里有一些值得注意的现象与符号计算有关。(这一段内容目前仅为开发者推测，尚未成为社区共识。)
   
      - 有时候会出现一条公式报错，但依赖它的下游公式却不报错的现象，如：`c = a + b; f(a, b) = c`，`c = a + b` 报错（因为依赖的 `a`，`b`未定义），但是 `f(a, b) = c` 不会报错，因此可以推断出在这里 `c` 被代换为 `a + b`，然后公式变为 `f(a, b) = a + b`，成功解析为一个函数。

      - 另一个现象与微积分功能有关。例如以下公式列表：
         - `c = a + b` -> 报错: "变量太多。请尝试定义 a 和 b。"
         - `\frac{d}{da} c` -> 计算为: 1
         - `\frac{d}{db} c` -> 计算为: 1
         - `\frac{d}{dc} c` -> 计算为: 1
         - `\frac{d}{dc} a` -> 计算为: 0
         - `\frac{d}{dc} (a + b)` -> 计算为: 0
         - `\frac{d}{dc} (2c)` -> 计算为: 2
         - `\frac{d}{dc} (2c^2)` -> 报错: "变量太多。请尝试定义 a 和 b。"
     
      - 由此可以看出 Desmos 的公式系统相比于其他比如编程语言代码的语法系统具有更强的容错性，一处地方的错误并不一定会像编程语言那样传导到其他所有地方让整个系统瘫痪。同时从这些例子可以看出 Desmos 解析公式时具有一定的符号计算能力。Desmos 在追溯符号定义和依赖关系之后，是将它们进行了符号性的代入的，在符号代入完毕之后才进行求值；在计算导数算符 `\frac{d}{du} f(u)` 时 `f(u)` 被进行了符号性的求导计算，得到对应表达式后才代入 `u` 等变量的值或者后续定义式。

   - 接下来我们尝试建模 Desmos 的公式解析流程：
      - Desmos 从 Mathquill 模块接收公式 LaTeX 代码后，首先对其进行语义解析。
         - 语义解析的分词步骤（符号识别, tokenize）中，部分特定多字符符号会具有更高的优先级，如 `sin` 会被识别为整体符号，而不是 `s` 和 `i` 和 `n` 的组合。除此之外desmos默认把多字符组合视为乘法，如 `abc` 会被识别为 `a`，`b`，`c` 的乘积。
      - 解析出符号后，识别定义式。任何形如 `a = expression(b)` 的表达式都会被识别为定义式，等号左边有且只有一个符号，`expression(b)` 为表达式。
      - 根据定义式建立符号表，符号表实际上也指明了各行公式之间的依赖关系。
      - （待完成）



	

#### 公式属性与依赖

Desmos 公式系统的几个重要特性：

1. **依赖引用**：所有公式类型都可以引用已定义的变量和函数。也即，在一张依赖图中，依赖项可以为所有的变量定义和函数定义，依赖方可以为所有类型的公式。如果把一个复合表达式也视为一个依赖树（依据其语法，实际上就是语法树），则依赖项的范围还包括各类表达式。不过为了性能考量，在依赖图里我们可能不会为每一个复合表达式建立一块细粒度的、完整的树，而只是把它整体视为一个节点。

2. **动态类型**：公式的类型可以随着公式内容变化或编辑而动态改变。

3. **绘图属性**：可绘制的公式（如方程、函数图像等）拥有多种绘图属性（颜色、线宽、透明度等），这些属性本身可以设置为表达式。

    Desmos 会为所有公式保留所有绘图属性。在一条公式的类型动态变化时，它的某一个绘图属性可能会变为"不可用"而被隐藏，但Desmos会记忆其值或其表达式，直到该绘图属性再次变得可用，此时恢复显示其值或其表达式。ExprBuild 遵循 Desmos 的做法，为所有公式开放所有绘图属性，无论当前是否可绘制。

4. **滑动条**：如果一条公式是数值类型的变量定义，则会自动附带一个滑动条，用户可拖动滑动条改变其值，也可点击旁边的"播放/暂停"按钮便捷地让滑动条自动滑动，形成系统随表达式值变化的动画。滑动条的最小值、最大值和步长也可以是表达式。和绘图属性一样，如果公式类型变化，Desmos 会记忆滑动条属性，ExprBuild 也遵循这一做法，对任意公式开放滑动条属性。

重述一遍，ExprBuild 的目标是让用户能够程序化地构建 Desmos 图表，同时确保构建过程符合 Desmos 的约束规则。

## 第二部分：Julia 技术路线探索

### Julia 语言选择理由

Julia 作为 ExprBuild 的实现语言具有显著优势：

1. **自然的数学语法**：Julia 的语法极其接近数学表达习惯，支持隐式乘法（如 `2x` 表示 `2*x`）、Unicode 数学符号（如 `√`, `π`）和标准数学运算符优先级

2. **强大的元编程能力**：Julia 的宏系统允许直接操作和转换代码的抽象语法树，非常适合构建表达式处理框架

3. **科学计算生态**：丰富的数学和科学计算库，特别是符号计算库如 `Symbolics.jl`，为表达式处理提供强大支持

---

### 技术架构设计

在 Julia 路线下，ExprBuild 可采用以下架构：

```
+------------------+        +----------------+        +---------------+
| 核心表达式系统   |  <-->  | Genie.jl 服务器 |  <-->  | JavaScript前端 |
| (Julia)          |        | (Julia)        |        | (Web浏览器)    |
+------------------+        +----------------+        +---------------+
```

#### 1. 核心表达式系统

利用 Julia 的符号计算能力和宏系统实现：

```julia
# 定义核心表达式类型
abstract type DesmosExpr end

# 使用统一的宏捕获表达式
macro desmos(expr)
    # 分析表达式并创建适当的DesmosExpr对象
    # 同时自动将对象赋值给同名变量
    # ...
end

# 示例用法 - 两种等价写法
@desmos a = 3  # 自动赋值给变量a
b = @desmos b = 4  # 显式赋值，效果相同
circle = @desmos x^2 + y^2 = a^2 + b^2
```

这种设计允许直接使用 Julia 的自然数学语法编写表达式，同时通过宏系统捕获和处理这些表达式。对于变量定义和函数定义，宏会自动将创建的对象赋值给同名变量，使得代码更加简洁。

#### 2. Genie.jl 服务器方案

使用 Genie.jl 框架提供 Web 服务：

- **API 端点**：提供 RESTful 接口处理表达式操作和 Desmos 状态生成
- **WebSocket 支持**：实现实时预览和双向通信
- **会话管理**：处理多用户和项目状态

```julia
# Genie.jl 路由示例
route("/api/compile") do
    # 接收表达式数据
    expr_data = jsonpayload()
    # 处理并返回 Desmos 状态
    desmos_state = compile_to_desmos(expr_data)
    return json(desmos_state)
end
```

#### 3. JavaScript 前端

前端负责用户交互和 Desmos API 集成：

- **代码编辑器**：基于 Monaco Editor 或 CodeMirror，支持语法高亮
- **Desmos 预览**：嵌入 Desmos API 展示生成结果
- **智能提示**：与服务器通信提供上下文相关的代码补全

---

### 依赖追踪与表达式管理

Julia 路线的一个关键优势是利用 `Symbolics.jl` 或自定义实现进行依赖追踪。换句话说，我们需要设计一套专门针对 Desmos 公式系统的对象模型。要么使用 Julia 语言本身已有的一套对表达式的建模（即 Julia AST，`Symbolics.jl`），要么设计自己的对象系统来表示 Desmos 公式。

这里探索一下自定义对象系统的可行性。

#### Desmos图表的多层次建模

需要明确一下，在 ExprBuild+Julia 项目中，对于一个Desmos图表有三种不同的表示层次：

1. **Desmos 内部表示**：Desmos 在其 JavaScript 代码中如何表示公式（我们无需关心）
2. **Desmos State JSON**：Desmos 图表的序列化格式，通过`getState()`和`setState()`操作，作为我们的输出目标
3. **ExprBuild 对象模型**：我们在 Julia 中设计的对象系统，用于表示和操作 Desmos 公式

我们的核心工作是设计第三层——ExprBuild 对象模型，使其既能利用 Julia 语言的表达力，又能准确映射到 Desmos State JSON。

#### ExprBuild 对象模型

在我们的设计中，Desmos 图表的核心元素被建模为以下对象：

1. **表达式对象**：表示数学表达式的结构和语义，如：
   - 变量引用（如 `a`）
   - 函数调用（如 `f(x)`）
   - 运算表达式（如 `a + b*sin(x)`）
   
   这些对象捕获表达式的结构，但不同于 Julia 的原生 AST，它们专门设计用于表示 Desmos 支持的表达式形式。

2. **公式对象**：表示 Desmos 中的一行公式，包含：
   - 表达式内容
   - 公式类型（变量定义、函数定义、方程等）
   - 绘图属性（颜色、线宽等，可以是常量或表达式）
   - 滑动条属性（若适用）
   
   公式对象是 Desmos "表达式列表"中的基本单位，每个公式对象最终会映射到 Desmos State JSON 中的一个条目。

3. **图表对象**：表示完整的 Desmos 图表，包含：
   - 公式列表（一个公式对象数组）
   - 依赖图（表示公式间引用关系）
   - 全局设置（坐标范围、网格显示等）

#### 依赖管理系统

基于上述对象模型，ExprBuild 需要实现专门的依赖管理系统：

1. **依赖识别**：当解析一个表达式时，系统自动识别其中引用的所有变量和函数名，构建依赖列表。例如：
   ```julia
   # 在Julia中，我们可以这样表示一个表达式及其依赖
   expr = @desmos x^2 + y^2 = r^2
   # 系统自动识别出依赖：r
   ```

2. **依赖图构建**：系统维护一个有向图，其中：
   - 节点表示公式对象
   - 边表示依赖关系（从被依赖的定义指向依赖方）
   - 图的结构确保了表达式求值的正确顺序

3. **冲突检测**：系统确保依赖图的一致性，防止：
   - 循环依赖（A依赖B，B又依赖A）
   - 同一变量或函数名称上有多个不同定义
   - 引用了未定义的变量或函数

4. **变量替换与优化**：支持在编译时进行变量内联和表达式简化：
   - 可以将常量变量替换为其值
   - 可以展开或简化某些表达式
   - 保持数学等价性的同时优化最终生成的 Desmos 状态

#### 从 Julia 语法到 ExprBuild 对象

ExprBuild 提供了从 Julia 语法到自定义对象模型的桥梁：

```julia
# 使用宏捕获 Julia 语法表达式，转换为 ExprBuild 对象
@desmos a = 3
circle = @desmos x^2 + y^2 = r^2
```

这里，`@desmos` 宏捕获 Julia 语法表达式，但不是简单地使用 Julia 的 AST，而是将其转换为我们自定义的 ExprBuild 对象模型。这种设计允许我们：

1. 利用 Julia 的自然数学语法
2. 在我们的对象模型中精确表示 Desmos 的约束和特性
3. 实现 Desmos 特有的功能（如滑动条、绘图属性等）

通过这种多层次建模方法，ExprBuild+Julia 能够在保持 Julia 语言自然数学表达能力的同时，精确映射 Desmos 的约束规则和特性。

---

### 开发体验优化

为提供流畅的开发体验，Julia 路线采用：

1. **热重载功能**：代码更改后自动重新编译和更新预览
2. **增量更新**：只重新计算受影响的表达式
3. **代码生成**：支持从 Desmos 状态反向生成 ExprBuild 代码

### 技术挑战与解决方案

1. **性能考量**：
   - 挑战：Julia 初次加载时间长
   - 解决方案：使用 PackageCompiler.jl 创建系统映像，减少启动时间

2. **前后端集成**：
   - 挑战：Julia 与 JavaScript 生态系统的无缝集成
   - 解决方案：明确的 JSON API 设计和 WebSocket 实时通信

3. **部署复杂性**：
   - 挑战：Julia 应用部署不如其他语言成熟
   - 解决方案：提供 Docker 容器化配置和详细部署指南

### Julia 路线的独特优势

1. **数学表达的纯粹性**：在所有备选方案中，Julia 提供最接近数学原生表达的语法
2. **符号计算能力**：内置强大的符号计算支持，简化表达式处理
3. **科学计算生态**：可以轻松扩展到更复杂的数学功能

### 未来扩展方向

1. **自定义绘图函数**：扩展 Desmos 的基本功能，支持更复杂的绘图操作
2. **动画序列生成**：创建数学动画的工具
3. **社区模板库**：共享和复用常用图表模板

---

ExprBuild 作为 Desmos 社区的粉丝项目，不追求成为正式的数学研究工具，而是专注于赋能创作者制作更加新奇、复杂的 Desmos 作品。Julia 技术路线提供了在数学表达自然性和编程灵活性之间的理想平衡，特别适合那些希望突破 Desmos 原生界面限制的社区创作者。